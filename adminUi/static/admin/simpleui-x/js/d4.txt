You're right. Since the dialog's width and height are now meant to be calculated dynamically, those attributes should not be directly bound to `dialogWidth` and `dialogHeight` in the template. Instead, we should calculate and apply these dimensions programmatically.

Here's how you can handle the dynamic sizing:

### Updated Template:

Remove the `:width` and `:height` bindings:

```html
<el-dialog
  v-for="(dialog, index) in dialogStack"
  :key="index"
  :title="dialog.name"
  :visible.sync="dialog.show"
  :before-close="handleClose"
  :custom-class="dialog.customClass"
>
  <iframe
    :ref="'contentIframe-' + index"
    :src="dialog.url"
    frameborder="0"
  ></iframe>
  <template v-slot:footer>
    <el-button @click="handleClose">Cancel</el-button>
    <el-button type="primary" @click="handleSave">Save</el-button>
  </template>
</el-dialog>
```

### JavaScript:

You don't need to use `dialog.dialogWidth` or `dialog.dialogHeight` since these are set dynamically based on the content of the iframe:

```javascript
export default {
  data() {
    return {
      dialogStack: [],
      dialogConfig: {
        url: '',
        name: '',
        show: false,
        customClass: '',
      },
    };
  },
  methods: {
    openDialog(url, name, customClass = '') {
      const viewportWidth = document.documentElement.clientWidth;

      if (viewportWidth > 800) {
        // إعدادات النافذة
        this.dialogConfig = {
          url,
          name,
          show: true,
          customClass,
        };

        // إضافة النافذة إلى المكدس
        this.dialogStack.push({ ...this.dialogConfig });

        // حساب الأبعاد بعد التصيير
        this.$nextTick(() => {
          this.checkContentReady(this.dialogStack.length - 1);
        });
      } else {
        // التعامل مع الشاشات الأصغر (فتح في علامة تبويب)
        this.openInTab({ url, name });
      }
    },

    checkContentReady(index) {
      const iframe = this.$refs[`contentIframe-${index}`];
      if (!iframe || !iframe[0]) return;

      const iframeDocument = iframe[0].contentDocument || iframe[0].contentWindow.document;

      setTimeout(() => {
        const isContentReady = iframeDocument.readyState === 'complete';

        if (isContentReady) {
          this.calculateDialogSize(index);
        } else {
          this.checkContentReady(index); // إعادة المحاولة إذا لم يكن المحتوى جاهزًا
        }
      }, 500);
    },

    calculateDialogSize(index) {
      const iframe = this.$refs[`contentIframe-${index}`][0];
      const iframeDocument = iframe.contentDocument || iframe.contentWindow.document;

      const contentHeight = iframeDocument.body.scrollHeight;
      const contentWidth = iframeDocument.body.scrollWidth;

      const dialogElement = this.$el.querySelectorAll('.el-dialog')[index];
      const headerHeight = dialogElement.querySelector('.el-dialog__header').offsetHeight;
      const bodyPadding = (
        parseInt(window.getComputedStyle(dialogElement.querySelector('.el-dialog__body')).paddingTop) +
        parseInt(window.getComputedStyle(dialogElement.querySelector('.el-dialog__body')).paddingBottom)
      );

      const totalHeight = contentHeight + headerHeight + bodyPadding;

      // ضبط الأبعاد مباشرة على عنصر الـ dialog
      dialogElement.style.width = `${contentWidth}px`;
      dialogElement.style.height = `${totalHeight}px`;
    },
  },
};
```

### شرح:

- **`dialogWidth` و `dialogHeight`**: لم نعد بحاجة إلى هذه الخصائص في الكائن `dialogConfig` لأنها ستحسب تلقائيًا من خلال `calculateDialogSize`.
- **حساب الحجم**: يتم حساب عرض وارتفاع الـ dialog بناءً على محتوى الـ iframe، ثم يتم تعيين هذه القيم مباشرة إلى الـ dialog باستخدام `style.width` و `style.height`.

بهذا الشكل، يتم ضبط حجم الـ dialog ديناميكيًا بناءً على المحتوى الموجود داخل الـ iframe بدون استخدام خصائص ثابتة مثل `dialogWidth` و `dialogHeight`.